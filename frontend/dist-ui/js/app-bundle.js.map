{"version":3,"file":"app-bundle.js","sources":["../../node_modules/dom-native/dist/utils.js","../../node_modules/dom-native/dist/event.js","../../node_modules/dom-native/dist/hub.js","../../node_modules/dom-native/dist/escapes.js","../../node_modules/@tauri-apps/api/external/tslib/tslib.es6.js","../../node_modules/@tauri-apps/api/core.js","../../node_modules/@tauri-apps/api/event.js"],"sourcesContent":["// --------- Object Utils --------- //\n// return true if the value is null, undefined, empty array, empty string, or empty object\nexport function isEmpty(v) {\n    const tof = typeof v;\n    if (v == null) {\n        return true;\n    }\n    if (v instanceof Array || tof === 'string') {\n        return (v.length === 0) ? true : false;\n    }\n    if (tof === 'object') {\n        // apparently 10x faster than Object.keys\n        for (const x in v) {\n            return false;\n        }\n        return true;\n    }\n    return false;\n}\n// TODO: need to document\nexport function val(rootObj, pathToValue, value) {\n    const setMode = (typeof value !== \"undefined\");\n    if (!rootObj) {\n        return rootObj;\n    }\n    // for now, return the rootObj if the pathToValue is empty or null or undefined\n    if (!pathToValue) {\n        return rootObj;\n    }\n    // if the pathToValue is already an array, do not parse it (this allow to support '.' in prop names)\n    const names = (pathToValue instanceof Array) ? pathToValue : pathToValue.split(\".\");\n    let name, currentNode = rootObj, currentIsMap, nextNode;\n    let i = 0, l = names.length, lIdx = l - 1;\n    for (i; i < l; i++) {\n        name = names[i];\n        currentIsMap = (currentNode instanceof Map);\n        nextNode = currentIsMap ? currentNode.get(name) : currentNode[name];\n        if (setMode) {\n            // if last index, set the value\n            if (i === lIdx) {\n                if (currentIsMap) {\n                    currentNode.set(name, value);\n                }\n                else {\n                    currentNode[name] = value;\n                }\n                currentNode = value;\n            }\n            else {\n                if (typeof nextNode === \"undefined\") {\n                    nextNode = {};\n                }\n                currentNode[name] = nextNode;\n                currentNode = nextNode;\n            }\n        }\n        else {\n            currentNode = nextNode;\n            if (typeof currentNode === \"undefined\") {\n                currentNode = undefined;\n                break;\n            }\n        }\n    }\n    if (setMode) {\n        return rootObj;\n    }\n    else {\n        return currentNode;\n    }\n}\n// Convert an indexed object to a pure array in the most efficient way (to-date)\n// See: https://jsperf.com/convert-nodelist-to-array, https://jsperf.com/array-from-to-nodelist\nexport function listAsArray(list) {\n    const arr = new Array(list.length);\n    for (let i = list.length - 1; i >= 0; i--) {\n        arr[i] = list[i];\n    }\n    return arr;\n}\n// --------- /Object Utils --------- //\n// --------- ensureType --------- //\nexport function ensureObject(obj, propName) {\n    return _ensure(obj, propName);\n}\n// Make sure that this obj[propName] is a js Map and returns it. \n// Otherwise, create a new one, set it, and return it.\nexport function ensureMap(obj, propName) {\n    return _ensure(obj, propName, Map);\n}\n// Make sure that this obj[propName] is a js Set and returns it. \n// Otherwise, create a new one, set it, and return it.\nexport function ensureSet(obj, propName) {\n    return _ensure(obj, propName, Set);\n}\n// same as ensureMap but for array\nexport function ensureArray(obj, propName) {\n    return _ensure(obj, propName, Array);\n}\nfunction _ensure(obj, propName, type) {\n    const isMap = (obj instanceof Map);\n    let v = (isMap) ? obj.get(propName) : obj[propName];\n    if (v == null) {\n        v = (type == null) ? {} : (type === Array) ? [] : (new type);\n        if (isMap) {\n            obj.set(propName, v);\n        }\n        else {\n            obj[propName] = v;\n        }\n    }\n    return v;\n}\n// Return an array from a value object. If value is null/undefined, return empty array. \n// If value is null or undefined, return empty array\n// If the value is an array it is returned as is\n// If the value is a object with forEach/length will return a new array for these values\n// Otherwise return single value array\nexport function asArray(value) {\n    if (value != null) {\n        if (value instanceof Array) {\n            return value;\n        }\n        // If it is a nodeList, copy the elements into a real array\n        else if (value.constructor && value.constructor.name === \"NodeList\") {\n            return Array.prototype.slice.call(value);\n        }\n        // if it is a function arguments\n        else if (value.toString() === \"[object Arguments]\") {\n            return Array.prototype.slice.call(value);\n        }\n        // otherwise we add value\n        else {\n            return [value];\n        }\n    }\n    // otherwise, return an empty array\n    return [];\n}\nconst emptyArray = Object.freeze([]);\n/**\n * Returns a readonly Node array from EventTarget, NodeList, Node[], or empty readonly array for null and undefined.\n */\nexport function asNodeArray(value) {\n    if (value != null) {\n        if (value instanceof Array) {\n            return value;\n        }\n        // If it is a nodeList, copy the elements into a real array\n        else if (value.constructor && value.constructor.name === \"NodeList\") {\n            return Array.prototype.slice.call(value);\n        }\n        // FIXME: Needs to handle the document fragment case. \n        // otherwise we add value\n        else {\n            return [value]; // Note: here we assume it the evenTarget is a node\n        }\n    }\n    // otherwise, return an empty array (readonly, so that we can )\n    return emptyArray;\n}\n// --------- /asType --------- //\n// --------- String Utils --------- //\nexport function splitAndTrim(str, sep) {\n    if (str == null) {\n        return [];\n    }\n    if (str.indexOf(sep) === -1) {\n        return [str.trim()];\n    }\n    return str.split(sep).map(trim);\n}\nfunction trim(str) {\n    return str.trim();\n}\n// --------- /String Utils --------- //\nconst _printOnceDone = {};\nexport function printOnce(msg) {\n    if (!_printOnceDone[msg]) {\n        console.log(msg);\n        _printOnceDone[msg] = true;\n    }\n}\n//# sourceMappingURL=utils.js.map","import { asNodeArray, ensureMap, ensureSet, splitAndTrim } from './utils.js';\nexport function addOnEvents(target, source) {\n    return Object.assign(target || {}, source);\n}\nexport function on(els, types, arg1, arg2, arg3) {\n    let opts;\n    let listener;\n    let selector;\n    // arg1 is a function, then no selector, arg1 is the listener, and arg2 is the potential eventOptions\n    if (arg1 instanceof Function) {\n        listener = arg1;\n        opts = arg2;\n    }\n    else {\n        selector = arg1;\n        listener = arg2;\n        opts = arg3;\n    }\n    // AddEventListenerOptions\t\n    let eventOptions;\n    if (opts && (opts.passive != null || opts.capture != null)) {\n        eventOptions = {};\n        if (opts.passive != null) {\n            eventOptions.passive = opts.passive;\n        }\n        if (opts.capture != null) {\n            eventOptions.capture = opts.capture;\n        }\n    }\n    if (els == null) {\n        return;\n    }\n    const silenceDisconnectedCtx = opts === null || opts === void 0 ? void 0 : opts.silenceDisconnectedCtx;\n    const ctx = opts === null || opts === void 0 ? void 0 : opts.ctx;\n    const ctxEl = (ctx instanceof HTMLElement) ? ctx : undefined;\n    const typeArray = splitAndTrim(types, \",\");\n    typeArray.forEach(function (type) {\n        const typeSelectorKey = buildTypeSelectorKey(type, selector);\n        asNodeArray(els).forEach(function (el) {\n            // This will the listener use for the even listener, which might differ\n            // from the listener function passed in case of a selector\n            let _listener = listener;\n            // if we have a selector, create the wrapper listener to do the matches on the selector\n            if (selector) {\n                _listener = function (evt) {\n                    let tgt = null;\n                    const target = evt.target;\n                    const currentTarget = evt.currentTarget;\n                    const ctx = (opts) ? opts.ctx : null;\n                    // if the \n                    if (silenceDisconnectedCtx === true && ctxEl != null) {\n                        if (!ctxEl.isConnected) {\n                            return;\n                        }\n                    }\n                    // if the target match the selector, then, easy, we call the listener\n                    if (target && target.matches(selector)) {\n                        // Note: While mouseEvent are readonly for its properties, it does allow to add custom properties\n                        // TODO: type narrowing needed.\n                        evt.selectTarget = target;\n                        listener.call(ctx, evt);\n                    }\n                    // now, if it does not, perhaps something in between the target and currentTarget\n                    // might match\n                    else {\n                        // TODO: type narrowing needed.\n                        tgt = evt.target.parentNode;\n                        // TODO: might need to check that tgt is not undefined as well. \n                        while (tgt !== null && tgt !== currentTarget && tgt !== document) {\n                            if (tgt.matches(selector)) { // selector is present here (see if above)\n                                // Note: While mouseEvent are readonly for its properties, it does allow to add custom properties\n                                evt.selectTarget = tgt;\n                                listener.call(ctx, evt);\n                                tgt = null;\n                                break;\n                            }\n                            tgt = tgt.parentNode;\n                        }\n                    }\n                };\n            }\n            // if we do not have a selector, but still havea  opts.ctx, then, need to wrap\n            else if (opts && opts.ctx) {\n                _listener = function (evt) {\n                    if (silenceDisconnectedCtx === true && ctxEl != null) {\n                        if (!ctxEl.isConnected) {\n                            return;\n                        }\n                    }\n                    listener.call(opts.ctx, evt);\n                };\n            }\n            const listenerRef = {\n                type: type,\n                listener: listener, // the listener as passed by the user\n                _listener: _listener, // an eventual wrap of the listener, or just point listener.\n            };\n            if (selector) {\n                listenerRef.selector = selector;\n            }\n            // If we have a namespace, they add it to the Ref, and to the listenerRefsByNs\n            // TODO: need to add listenerRef in a nsDic if if there a opts.ns\n            if (opts && opts.ns) {\n                listenerRef.ns = opts.ns;\n                let listenerRefSetByNs = ensureMap(el, \"listenerRefsByNs\");\n                let listenerRefSet = ensureSet(listenerRefSetByNs, opts.ns);\n                listenerRefSet.add(listenerRef);\n            }\n            // add the listenerRef as listener:listenerRef entry for this typeSelectorKey in the listenerDic\n            let listenerDic = ensureMap(el, \"listenerDic\");\n            let listenerRefByListener = ensureMap(listenerDic, typeSelectorKey);\n            listenerRefByListener.set(listener, listenerRef);\n            // do the binding\n            // TODO: fix typing here.\n            if (opts != null && opts.nextFrame === true) {\n                requestAnimationFrame(function () {\n                    el.addEventListener(type, _listener, eventOptions);\n                });\n            }\n            else {\n                el.addEventListener(type, _listener, eventOptions);\n            }\n        }); // /utils.asArray(els).forEach(function(el){\n    }); // /types.forEach(function(type){\n}\nexport function off(els, type_or_opts, selector_or_listener, maybe_listener) {\n    if (els == null) {\n        return;\n    }\n    // for now, opts is only the first position\n    const opts = (type_or_opts && type_or_opts.ns) ? type_or_opts : null;\n    const type = (opts === null) ? type_or_opts : null;\n    let selector = null;\n    let listener;\n    const tof = typeof selector_or_listener;\n    if (tof === 'function') {\n        selector = null;\n        listener = selector_or_listener;\n    }\n    else if (tof === 'string') {\n        selector = selector_or_listener;\n        listener = maybe_listener;\n    }\n    // --------- off(els, {ns}) --------- //\n    // if we have a .off(els,{ns:..}) then we do check only the ns\n    if (opts && opts.ns) {\n        const ns = opts.ns;\n        asNodeArray(els).forEach(function (el) {\n            const listenerDic = el.listenerDic;\n            const listenerRefsByNs = el.listenerRefsByNs;\n            let listenerRefSet;\n            if (listenerRefsByNs && listenerDic) {\n                listenerRefSet = listenerRefsByNs.get(ns);\n                if (listenerRefSet) {\n                    // if we get the set, we remove them all\n                    listenerRefSet.forEach(function (listenerRef) {\n                        // we remove the event listener\n                        el.removeEventListener(listenerRef.type, listenerRef._listener);\n                        // need to remove it from the listenerDic\n                        const typeSelectorKey = buildTypeSelectorKey(listenerRef.type, listenerRef.selector);\n                        const listenerRefMapByListener = listenerDic.get(typeSelectorKey);\n                        if (listenerRefMapByListener && listenerRefMapByListener.has(listenerRef.listener)) {\n                            listenerRefMapByListener.delete(listenerRef.listener);\n                        }\n                        else {\n                            // eventua already removed\n                            //console.log(\"INTERNAL INFO - should have a listener in el.listenerDic for \" + typeSelectorKey);\n                        }\n                    });\n                    // we remove this namespace now that all event handlers has been removed\n                    listenerRefsByNs.delete(ns);\n                }\n            }\n        });\n        return;\n    }\n    // --------- /off(els, {ns}) --------- //\n    const typeSelectorKey = buildTypeSelectorKey(type, selector);\n    asNodeArray(els).forEach(function (el) {\n        // First, get the listenerRefByListener for this type/selectory\n        const listenerRefMapByListener = (el.listenerDic) ? el.listenerDic.get(typeSelectorKey) : null; //val(el, [\"listenerDic\", typeSelectorKey]);\n        // for now, if we do not have a listenerRef for this type/[selector], we throw an error\n        if (!listenerRefMapByListener) {\n            console.log(\"WARNING - Cannot do .off() since this type-selector '\" + typeSelectorKey +\n                \"' event was not bound with .on(). We will add support for this later.\");\n            return;\n        }\n        // if we do not have a listener function, this mean we need to remove all events for this type/selector\n        if (typeof listener === \"undefined\" && type) {\n            listenerRefMapByListener.forEach(function (listenerRef) {\n                // Note: Here, type === listenerRef.type\n                // remove the event\n                // TODO: check typing assumption\n                el.removeEventListener(type, listenerRef._listener);\n            });\n            el.listenerDic.delete(typeSelectorKey);\n        }\n        // if we have a listener, then, just remove this one.\n        else {\n            // check that we have the map. \n            const listenerRef = (listener) ? listenerRefMapByListener.get(listener) : null;\n            if (!listenerRef) {\n                console.log(\"WARNING - Cannot do .off() since no listenerRef for \" + typeSelectorKey +\n                    \" and function \\n\" + listener + \"\\n were found. Probably was not registered via on()\");\n                return;\n            }\n            // remove the event\n            // TODO: check typing assumption\n            el.removeEventListener(type, listenerRef._listener);\n            // remove it from the map\n            // TODO: check typing ! assumption\n            listenerRefMapByListener.delete(listener);\n        }\n    });\n}\n//#endregion ---------- /Public off API ---------- \n//#region    ---------- Public trigger API ---------- \nconst customDefaultProps = {\n    bubbles: true,\n    cancelable: true\n};\nexport function trigger(els, type, evtInit) {\n    if (els == null) {\n        return;\n    } // for now make it null/undefined proof\n    asNodeArray(els).forEach(function (el) {\n        const evt = new CustomEvent(type, Object.assign({}, customDefaultProps, { selectTarget: el }, evtInit));\n        el.dispatchEvent(evt);\n    });\n}\n//#endregion ---------- /Public trigger API ---------- \n//#region    ---------- Public bindDOMEvents API ---------- \n/**\n * Bind a list of bindings\n *\n * @param typeAndSelector e.g., `click` or `click; button.add`\n */\nexport function bindOnEvents(el, eventDics, opts) {\n    eventDics = (eventDics instanceof Array) ? eventDics : [eventDics]; // make we have an array of eventDic\n    for (const eventDic of eventDics) {\n        for (const selector in eventDic) {\n            bindOnEvent(el, selector, eventDic[selector], opts);\n        }\n    }\n}\n/**\n * Bind one event to a el by appropriately parsing the `typeAndSelector` might contains a selector;\n *\n * @param typeAndSelector e.g., `click` or `click; button.add`\n */\nexport function bindOnEvent(el, typeAndSelector, fn, opts) {\n    let selectorSplitted = typeAndSelector.trim().split(\";\"); // e.g., [\"click\", \" button.add\"]\n    let type = selectorSplitted[0].trim(); // e.g., \"click\"\n    let selector = null; // e.g., \"button.add\"\n    if (selectorSplitted.length > 1) {\n        selector = selectorSplitted[1].trim();\n    }\n    on(el, type, selector, fn, opts);\n}\n//#endregion ---------- /Public bindDOMEvents API ---------- \nfunction buildTypeSelectorKey(type, selector) {\n    return (selector) ? (type + \"--\" + selector) : type;\n}\n//# sourceMappingURL=event.js.map","import { ensureArray, splitAndTrim } from './utils.js';\n;\n//#endregion ---------- /Public Types ---------- \n//#region    ---------- Public bindHubEvents ---------- \nexport function addHubEvents(target, source) {\n    const t = (target == null) ? [] : (target instanceof Array) ? target : [target];\n    (source instanceof Array) ? t.push(...source) : t.push(source);\n    return t;\n}\nexport function bindHubEvents(bindings, opts) {\n    const bindingList = (bindings instanceof Array) ? bindings : [bindings];\n    for (const bindings of bindingList) {\n        const infoList = listHubInfos(bindings);\n        infoList.forEach(function (info) {\n            info.hub.sub(info.topics, info.labels, info.fun, opts);\n        });\n    }\n}\n/**\n * Unbinding a list of bindings. For now, MUST have nsObject.\n * @param bindings\n * @param nsObject\n */\nexport function unbindHubEvents(bindings, nsObject) {\n    const bindingList = (bindings instanceof Array) ? bindings : [bindings];\n    bindingList.forEach(function (hubEvents) {\n        const infoList = listHubInfos(hubEvents);\n        infoList.forEach(function (info) {\n            info.hub.unsub(nsObject);\n        });\n    });\n}\n/**\n * @param {*} hubEvents could be {\"hubName; topics[; labels]\": fn}\n * \t\t\t\t\t\t\t\t\t\t\tor {hubName: {\"topics[; labels]\": fn}}\n * @returns {hub, topics, labels}[]\n */\nfunction listHubInfos(hubEvents) {\n    const infoList = [];\n    for (const key in hubEvents) {\n        const val = hubEvents[key];\n        // If we have FnBySelector, then, hub name is in the selector, getHubInfo will extract it\n        // \"hubName; topics[; labels]\": fn}\n        if (val instanceof Function) {\n            infoList.push(getHubInfo(key, null, val));\n        }\n        // otherwise, if val is an object, then, thee key is the name of the hub, so get/create it.\n        // {hubName: {\"topics[; labels]\": fn}}\n        else {\n            const _hub = hub(key);\n            for (const key2 in val) {\n                infoList.push(getHubInfo(key2, _hub, val[key2]));\n            }\n        }\n    }\n    return infoList;\n}\n// returns {hub, topics, labels}\n// hub is optional, if not present, assume the name will be the first item will be in the str\nfunction getHubInfo(str, _hub, fun) {\n    const a = splitAndTrim(str, \";\");\n    // if no hub, then, assume it is in the str\n    const topicIdx = (_hub) ? 0 : 1;\n    _hub = (!_hub) ? hub(a[0]) : _hub;\n    const info = {\n        topics: a[topicIdx],\n        fun: fun,\n        hub: _hub\n    };\n    if (a.length > topicIdx + 1) {\n        info.labels = a[topicIdx + 1];\n    }\n    return info;\n}\n//#endregion ---------- /Private Helpers ---------- \n//#region    ---------- Public Factory ---------- \n/** Singleton hub factory */\nexport function hub(name) {\n    if (name == null) {\n        throw new Error('dom-native INVALID API CALLS: hub(name) require a name (no name was given).');\n    }\n    let hub = hubDic.get(name);\n    // if it does not exist, we create and set it. \n    if (hub === undefined) {\n        hub = new HubImpl(name);\n        hubDic.set(name, hub);\n        // create the hubData\n        hubDataDic.set(name, new HubData(name));\n    }\n    return hub;\n}\n// User Hub object exposing the public API\nconst hubDic = new Map();\n// Data for each hub (by name)\nconst hubDataDic = new Map();\nclass HubImpl {\n    constructor(name) {\n        this.name = name;\n    }\n    sub(topics, labels_or_handler, handler_or_opts, opts) {\n        //// Build the arguments\n        let labels;\n        let handler;\n        // if the first arg is function, then, no labels\n        if (labels_or_handler instanceof Function) {\n            labels = null;\n            handler = labels_or_handler;\n            opts = handler_or_opts;\n        }\n        else {\n            labels = labels_or_handler;\n            handler = handler_or_opts;\n            // opts = opts;\n        }\n        //// Normalize topic and label to arrays\n        const topicArray = splitAndTrim(topics, \",\");\n        const labelArray = (labels != null) ? splitAndTrim(labels, \",\") : null;\n        //// make opts (always defined at least an emtpy object)\n        opts = makeOpts(opts);\n        //// add the event to the hubData\n        const hubData = hubDataDic.get(this.name); // by hub(...) factory function, this is garanteed\n        hubData.addEvent(topicArray, labelArray, handler, opts);\n    }\n    unsub(ns) {\n        const hubData = hubDataDic.get(this.name); // by factory contract, this always exist.\n        hubData.removeRefsForNs(ns.ns);\n    }\n    pub(topics, labels, data) {\n        // ARG SHIFTING: if data is undefined, we shift args to the RIGHT\n        if (typeof data === \"undefined\") {\n            data = labels;\n            labels = null;\n        }\n        //// Normalize topic and label to arrays\n        const topicArray = splitAndTrim(topics, \",\");\n        const labelArray = (labels != null) ? splitAndTrim(labels, \",\") : null;\n        const hubData = hubDataDic.get(this.name);\n        const hasLabels = (labels != null && labels.length > 0);\n        // if we have labels, then, we send the labels bound events first\n        if (hasLabels) {\n            hubData.getRefs(topicArray, labelArray).forEach(function (ref) {\n                invokeRef(ref, data);\n            });\n        }\n        // then, we send the topic only bound\n        hubData.getRefs(topicArray, null).forEach(function (ref) {\n            // if this send, has label, then, we make sure we invoke for each of this label\n            if (hasLabels) {\n                labelArray.forEach(function (label) {\n                    invokeRef(ref, data, label);\n                });\n            }\n            // if we do not have labels, then, just call it.\n            else {\n                invokeRef(ref, data);\n            }\n        });\n    }\n    deleteHub() {\n        hubDic.delete(this.name);\n        hubDataDic.delete(this.name);\n    }\n}\n// TODO: This was maded to have it private to the hub. Now that we are using trypescript, we might want to use private and store it in the Hub. \nclass HubData {\n    constructor(name) {\n        this.refsByNs = new Map();\n        this.refsByTopic = new Map();\n        this.refsByTopicLabel = new Map();\n        this.name = name;\n    }\n    addEvent(topics, labels, fun, opts) {\n        const refs = buildRefs(topics, labels, fun, opts);\n        const refsByNs = this.refsByNs;\n        const refsByTopic = this.refsByTopic;\n        const refsByTopicLabel = this.refsByTopicLabel;\n        refs.forEach(function (ref) {\n            // add this ref to the ns dictionary\n            // TODO: probably need to add an custom \"ns\"\n            if (ref.ns != null) {\n                ensureArray(refsByNs, ref.ns).push(ref);\n            }\n            // if we have a label, add this ref to the topicLabel dictionary\n            if (ref.label != null) {\n                ensureArray(refsByTopicLabel, buildTopicLabelKey(ref.topic, ref.label)).push(ref);\n            }\n            // Otherwise, add it to this ref this topic\n            else {\n                ensureArray(refsByTopic, ref.topic).push(ref);\n            }\n        });\n    }\n    ;\n    getRefs(topics, labels) {\n        const refs = [];\n        const refsByTopic = this.refsByTopic;\n        const refsByTopicLabel = this.refsByTopicLabel;\n        topics.forEach(function (topic) {\n            // if we do not have labels, then, just look in the topic dic\n            if (labels == null || labels.length === 0) {\n                const topicRefs = refsByTopic.get(topic);\n                if (topicRefs) {\n                    refs.push.apply(refs, topicRefs);\n                }\n            }\n            // if we have some labels, then, take those in accounts\n            else {\n                labels.forEach(function (label) {\n                    const topicLabelRefs = refsByTopicLabel.get(buildTopicLabelKey(topic, label));\n                    if (topicLabelRefs) {\n                        refs.push.apply(refs, topicLabelRefs);\n                    }\n                });\n            }\n        });\n        return refs;\n    }\n    ;\n    removeRefsForNs(ns) {\n        const refsByTopic = this.refsByTopic;\n        const refsByTopicLabel = this.refsByTopicLabel;\n        const refsByNs = this.refsByNs;\n        const refs = this.refsByNs.get(ns);\n        if (refs != null) {\n            // we remove each ref from the corresponding dic\n            refs.forEach(function (ref) {\n                // First, we get the refs from the topic or topiclabel\n                let refList;\n                if (ref.label != null) {\n                    const topicLabelKey = buildTopicLabelKey(ref.topic, ref.label);\n                    refList = refsByTopicLabel.get(topicLabelKey);\n                }\n                else {\n                    refList = refsByTopic.get(ref.topic);\n                }\n                // Then, for the refList array, we remove the ones that match this object\n                let idx;\n                while ((idx = refList.indexOf(ref)) !== -1) {\n                    refList.splice(idx, 1);\n                }\n            });\n            // we remove them all form the refsByNs\n            refsByNs.delete(ns);\n        }\n    }\n    ;\n}\n// static/private\nfunction buildRefs(topics, labels, fun, opts) {\n    let refs = [];\n    topics.forEach(function (topic) {\n        // if we do not have any labels, then, just add this topic\n        if (labels == null || labels.length === 0) {\n            refs.push({\n                topic: topic,\n                fun: fun,\n                ns: opts.ns,\n                ctx: opts.ctx\n            });\n        }\n        // if we have one or more labels, then, we add for those label\n        else {\n            labels.forEach(function (label) {\n                refs.push({\n                    topic: topic,\n                    label: label,\n                    fun: fun,\n                    ns: opts.ns,\n                    ctx: opts.ctx\n                });\n            });\n        }\n    });\n    return refs;\n}\n// static/private: return a safe opts. If opts is a string, then, assume is it the {ns}\nconst emptyOpts = {};\nfunction makeOpts(opts) {\n    if (opts == null) {\n        opts = emptyOpts;\n    }\n    else {\n        if (typeof opts === \"string\") {\n            opts = { ns: opts };\n        }\n    }\n    return opts;\n}\n// static/private\nfunction buildTopicLabelKey(topic, label) {\n    return topic + \"-!-\" + label;\n}\n// static/private: call ref method (with optional label override)\nfunction invokeRef(ref, data, label) {\n    const info = {\n        topic: ref.topic,\n        label: ref.label || label,\n        ns: ref.ns\n    };\n    ref.fun.call(ref.ctx, data, info);\n}\n//#endregion ---------- /Hub Implementation ----------\n//# sourceMappingURL=hub.js.map","const _elHtml = document.createElement('div');\n/** Shortname for escapeHtml */\nexport const xh = escapeHtml;\n/** Escape a HTML content using native DOM textContent to innerHTML capability */\nexport function escapeHtml(txt) {\n    _elHtml.textContent = txt;\n    const safeTxt = _elHtml.innerHTML;\n    _elHtml.textContent = null;\n    return safeTxt;\n}\nconst _elAttr = document.createElement('e');\n/** Shortname for escapeAttr */\nexport const xa = escapeAttr;\n/** Escape a string as a HTML Attribute content using native DOM attribute serialization */\nexport function escapeAttr(txt) {\n    _elAttr.setAttribute('a', txt);\n    // .outerHTML will generate '<e a=\"...\"></e>';\n    const html = _elAttr.outerHTML;\n    const safeTxt = html.substring(6, html.length - 6);\n    _elHtml.setAttribute('a', '');\n    return safeTxt;\n}\n//# sourceMappingURL=escapes.js.map","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nexport { __classPrivateFieldGet, __classPrivateFieldSet };\n","import { __classPrivateFieldGet, __classPrivateFieldSet } from './external/tslib/tslib.es6.js';\n\n// Copyright 2019-2024 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\nvar _Channel_onmessage, _Channel_nextMessageIndex, _Channel_pendingMessages, _Channel_messageEndIndex, _Resource_rid;\n/**\n * Invoke your custom commands.\n *\n * This package is also accessible with `window.__TAURI__.core` when [`app.withGlobalTauri`](https://v2.tauri.app/reference/config/#withglobaltauri) in `tauri.conf.json` is set to `true`.\n * @module\n */\n/**\n * A key to be used to implement a special function\n * on your types that define how your type should be serialized\n * when passing across the IPC.\n * @example\n * Given a type in Rust that looks like this\n * ```rs\n * #[derive(serde::Serialize, serde::Deserialize)\n * enum UserId {\n *   String(String),\n *   Number(u32),\n * }\n * ```\n * `UserId::String(\"id\")` would be serialized into `{ String: \"id\" }`\n * and so we need to pass the same structure back to Rust\n * ```ts\n * import { SERIALIZE_TO_IPC_FN } from \"@tauri-apps/api/core\"\n *\n * class UserIdString {\n *   id\n *   constructor(id) {\n *     this.id = id\n *   }\n *\n *   [SERIALIZE_TO_IPC_FN]() {\n *     return { String: this.id }\n *   }\n * }\n *\n * class UserIdNumber {\n *   id\n *   constructor(id) {\n *     this.id = id\n *   }\n *\n *   [SERIALIZE_TO_IPC_FN]() {\n *     return { Number: this.id }\n *   }\n * }\n *\n * type UserId = UserIdString | UserIdNumber\n * ```\n *\n */\n// if this value changes, make sure to update it in:\n// 1. ipc.js\n// 2. process-ipc-message-fn.js\nconst SERIALIZE_TO_IPC_FN = '__TAURI_TO_IPC_KEY__';\n/**\n * Stores the callback in a known location, and returns an identifier that can be passed to the backend.\n * The backend uses the identifier to `eval()` the callback.\n *\n * @return An unique identifier associated with the callback function.\n *\n * @since 1.0.0\n */\nfunction transformCallback(\n// TODO: Make this not optional in v3\ncallback, once = false) {\n    return window.__TAURI_INTERNALS__.transformCallback(callback, once);\n}\nclass Channel {\n    constructor(onmessage) {\n        _Channel_onmessage.set(this, void 0);\n        // the index is used as a mechanism to preserve message order\n        _Channel_nextMessageIndex.set(this, 0);\n        _Channel_pendingMessages.set(this, []);\n        _Channel_messageEndIndex.set(this, void 0);\n        __classPrivateFieldSet(this, _Channel_onmessage, onmessage || (() => { }), \"f\");\n        this.id = transformCallback((rawMessage) => {\n            const index = rawMessage.index;\n            if ('end' in rawMessage) {\n                if (index == __classPrivateFieldGet(this, _Channel_nextMessageIndex, \"f\")) {\n                    this.cleanupCallback();\n                }\n                else {\n                    __classPrivateFieldSet(this, _Channel_messageEndIndex, index, \"f\");\n                }\n                return;\n            }\n            const message = rawMessage.message;\n            // Process the message if we're at the right order\n            if (index == __classPrivateFieldGet(this, _Channel_nextMessageIndex, \"f\")) {\n                __classPrivateFieldGet(this, _Channel_onmessage, \"f\").call(this, message);\n                __classPrivateFieldSet(this, _Channel_nextMessageIndex, __classPrivateFieldGet(this, _Channel_nextMessageIndex, \"f\") + 1, \"f\");\n                // process pending messages\n                while (__classPrivateFieldGet(this, _Channel_nextMessageIndex, \"f\") in __classPrivateFieldGet(this, _Channel_pendingMessages, \"f\")) {\n                    const message = __classPrivateFieldGet(this, _Channel_pendingMessages, \"f\")[__classPrivateFieldGet(this, _Channel_nextMessageIndex, \"f\")];\n                    __classPrivateFieldGet(this, _Channel_onmessage, \"f\").call(this, message);\n                    // eslint-disable-next-line @typescript-eslint/no-array-delete\n                    delete __classPrivateFieldGet(this, _Channel_pendingMessages, \"f\")[__classPrivateFieldGet(this, _Channel_nextMessageIndex, \"f\")];\n                    __classPrivateFieldSet(this, _Channel_nextMessageIndex, __classPrivateFieldGet(this, _Channel_nextMessageIndex, \"f\") + 1, \"f\");\n                }\n                if (__classPrivateFieldGet(this, _Channel_nextMessageIndex, \"f\") === __classPrivateFieldGet(this, _Channel_messageEndIndex, \"f\")) {\n                    this.cleanupCallback();\n                }\n            }\n            // Queue the message if we're not\n            else {\n                // eslint-disable-next-line security/detect-object-injection\n                __classPrivateFieldGet(this, _Channel_pendingMessages, \"f\")[index] = message;\n            }\n        });\n    }\n    cleanupCallback() {\n        window.__TAURI_INTERNALS__.unregisterCallback(this.id);\n    }\n    set onmessage(handler) {\n        __classPrivateFieldSet(this, _Channel_onmessage, handler, \"f\");\n    }\n    get onmessage() {\n        return __classPrivateFieldGet(this, _Channel_onmessage, \"f\");\n    }\n    [(_Channel_onmessage = new WeakMap(), _Channel_nextMessageIndex = new WeakMap(), _Channel_pendingMessages = new WeakMap(), _Channel_messageEndIndex = new WeakMap(), SERIALIZE_TO_IPC_FN)]() {\n        return `__CHANNEL__:${this.id}`;\n    }\n    toJSON() {\n        // eslint-disable-next-line security/detect-object-injection\n        return this[SERIALIZE_TO_IPC_FN]();\n    }\n}\nclass PluginListener {\n    constructor(plugin, event, channelId) {\n        this.plugin = plugin;\n        this.event = event;\n        this.channelId = channelId;\n    }\n    async unregister() {\n        return invoke(`plugin:${this.plugin}|remove_listener`, {\n            event: this.event,\n            channelId: this.channelId\n        });\n    }\n}\n/**\n * Adds a listener to a plugin event.\n *\n * @returns The listener object to stop listening to the events.\n *\n * @since 2.0.0\n */\nasync function addPluginListener(plugin, event, cb) {\n    const handler = new Channel(cb);\n    try {\n        return invoke(`plugin:${plugin}|register_listener`, {\n            event,\n            handler\n        }).then(() => new PluginListener(plugin, event, handler.id));\n    }\n    catch {\n        // TODO(v3): remove this fallback\n        // note: we must try with camelCase here for backwards compatibility\n        return invoke(`plugin:${plugin}|registerListener`, { event, handler }).then(() => new PluginListener(plugin, event, handler.id));\n    }\n}\n/**\n * Get permission state for a plugin.\n *\n * This should be used by plugin authors to wrap their actual implementation.\n */\nasync function checkPermissions(plugin) {\n    return invoke(`plugin:${plugin}|check_permissions`);\n}\n/**\n * Request permissions.\n *\n * This should be used by plugin authors to wrap their actual implementation.\n */\nasync function requestPermissions(plugin) {\n    return invoke(`plugin:${plugin}|request_permissions`);\n}\n/**\n * Sends a message to the backend.\n * @example\n * ```typescript\n * import { invoke } from '@tauri-apps/api/core';\n * await invoke('login', { user: 'tauri', password: 'poiwe3h4r5ip3yrhtew9ty' });\n * ```\n *\n * @param cmd The command name.\n * @param args The optional arguments to pass to the command.\n * @param options The request options.\n * @return A promise resolving or rejecting to the backend response.\n *\n * @since 1.0.0\n */\nasync function invoke(cmd, args = {}, options) {\n    return window.__TAURI_INTERNALS__.invoke(cmd, args, options);\n}\n/**\n * Convert a device file path to an URL that can be loaded by the webview.\n * Note that `asset:` and `http://asset.localhost` must be added to [`app.security.csp`](https://v2.tauri.app/reference/config/#csp-1) in `tauri.conf.json`.\n * Example CSP value: `\"csp\": \"default-src 'self' ipc: http://ipc.localhost; img-src 'self' asset: http://asset.localhost\"` to use the asset protocol on image sources.\n *\n * Additionally, `\"enable\" : \"true\"` must be added to [`app.security.assetProtocol`](https://v2.tauri.app/reference/config/#assetprotocolconfig)\n * in `tauri.conf.json` and its access scope must be defined on the `scope` array on the same `assetProtocol` object.\n *\n * @param  filePath The file path.\n * @param  protocol The protocol to use. Defaults to `asset`. You only need to set this when using a custom protocol.\n * @example\n * ```typescript\n * import { appDataDir, join } from '@tauri-apps/api/path';\n * import { convertFileSrc } from '@tauri-apps/api/core';\n * const appDataDirPath = await appDataDir();\n * const filePath = await join(appDataDirPath, 'assets/video.mp4');\n * const assetUrl = convertFileSrc(filePath);\n *\n * const video = document.getElementById('my-video');\n * const source = document.createElement('source');\n * source.type = 'video/mp4';\n * source.src = assetUrl;\n * video.appendChild(source);\n * video.load();\n * ```\n *\n * @return the URL that can be used as source on the webview.\n *\n * @since 1.0.0\n */\nfunction convertFileSrc(filePath, protocol = 'asset') {\n    return window.__TAURI_INTERNALS__.convertFileSrc(filePath, protocol);\n}\n/**\n * A rust-backed resource stored through `tauri::Manager::resources_table` API.\n *\n * The resource lives in the main process and does not exist\n * in the Javascript world, and thus will not be cleaned up automatiacally\n * except on application exit. If you want to clean it up early, call {@linkcode Resource.close}\n *\n * @example\n * ```typescript\n * import { Resource, invoke } from '@tauri-apps/api/core';\n * export class DatabaseHandle extends Resource {\n *   static async open(path: string): Promise<DatabaseHandle> {\n *     const rid: number = await invoke('open_db', { path });\n *     return new DatabaseHandle(rid);\n *   }\n *\n *   async execute(sql: string): Promise<void> {\n *     await invoke('execute_sql', { rid: this.rid, sql });\n *   }\n * }\n * ```\n */\nclass Resource {\n    get rid() {\n        return __classPrivateFieldGet(this, _Resource_rid, \"f\");\n    }\n    constructor(rid) {\n        _Resource_rid.set(this, void 0);\n        __classPrivateFieldSet(this, _Resource_rid, rid, \"f\");\n    }\n    /**\n     * Destroys and cleans up this resource from memory.\n     * **You should not call any method on this object anymore and should drop any reference to it.**\n     */\n    async close() {\n        return invoke('plugin:resources|close', {\n            rid: this.rid\n        });\n    }\n}\n_Resource_rid = new WeakMap();\nfunction isTauri() {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n    return !!(globalThis || window).isTauri;\n}\n\nexport { Channel, PluginListener, Resource, SERIALIZE_TO_IPC_FN, addPluginListener, checkPermissions, convertFileSrc, invoke, isTauri, requestPermissions, transformCallback };\n","import { invoke, transformCallback } from './core.js';\n\n// Copyright 2019-2024 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n/**\n * The event system allows you to emit events to the backend and listen to events from it.\n *\n * This package is also accessible with `window.__TAURI__.event` when [`app.withGlobalTauri`](https://v2.tauri.app/reference/config/#withglobaltauri) in `tauri.conf.json` is set to `true`.\n * @module\n */\n/**\n * @since 1.1.0\n */\nvar TauriEvent;\n(function (TauriEvent) {\n    TauriEvent[\"WINDOW_RESIZED\"] = \"tauri://resize\";\n    TauriEvent[\"WINDOW_MOVED\"] = \"tauri://move\";\n    TauriEvent[\"WINDOW_CLOSE_REQUESTED\"] = \"tauri://close-requested\";\n    TauriEvent[\"WINDOW_DESTROYED\"] = \"tauri://destroyed\";\n    TauriEvent[\"WINDOW_FOCUS\"] = \"tauri://focus\";\n    TauriEvent[\"WINDOW_BLUR\"] = \"tauri://blur\";\n    TauriEvent[\"WINDOW_SCALE_FACTOR_CHANGED\"] = \"tauri://scale-change\";\n    TauriEvent[\"WINDOW_THEME_CHANGED\"] = \"tauri://theme-changed\";\n    TauriEvent[\"WINDOW_CREATED\"] = \"tauri://window-created\";\n    TauriEvent[\"WEBVIEW_CREATED\"] = \"tauri://webview-created\";\n    TauriEvent[\"DRAG_ENTER\"] = \"tauri://drag-enter\";\n    TauriEvent[\"DRAG_OVER\"] = \"tauri://drag-over\";\n    TauriEvent[\"DRAG_DROP\"] = \"tauri://drag-drop\";\n    TauriEvent[\"DRAG_LEAVE\"] = \"tauri://drag-leave\";\n})(TauriEvent || (TauriEvent = {}));\n/**\n * Unregister the event listener associated with the given name and id.\n *\n * @ignore\n * @param event The event name\n * @param eventId Event identifier\n * @returns\n */\nasync function _unlisten(event, eventId) {\n    window.__TAURI_EVENT_PLUGIN_INTERNALS__.unregisterListener(event, eventId);\n    await invoke('plugin:event|unlisten', {\n        event,\n        eventId\n    });\n}\n/**\n * Listen to an emitted event to any {@link EventTarget|target}.\n *\n * @example\n * ```typescript\n * import { listen } from '@tauri-apps/api/event';\n * const unlisten = await listen<string>('error', (event) => {\n *   console.log(`Got error, payload: ${event.payload}`);\n * });\n *\n * // you need to call unlisten if your handler goes out of scope e.g. the component is unmounted\n * unlisten();\n * ```\n *\n * @param event Event name. Must include only alphanumeric characters, `-`, `/`, `:` and `_`.\n * @param handler Event handler callback.\n * @param options Event listening options.\n * @returns A promise resolving to a function to unlisten to the event.\n * Note that removing the listener is required if your listener goes out of scope e.g. the component is unmounted.\n *\n * @since 1.0.0\n */\nasync function listen(event, handler, options) {\n    var _a;\n    const target = typeof (options === null || options === void 0 ? void 0 : options.target) === 'string'\n        ? { kind: 'AnyLabel', label: options.target }\n        : ((_a = options === null || options === void 0 ? void 0 : options.target) !== null && _a !== void 0 ? _a : { kind: 'Any' });\n    return invoke('plugin:event|listen', {\n        event,\n        target,\n        handler: transformCallback(handler)\n    }).then((eventId) => {\n        return async () => _unlisten(event, eventId);\n    });\n}\n/**\n * Listens once to an emitted event to any {@link EventTarget|target}.\n *\n * @example\n * ```typescript\n * import { once } from '@tauri-apps/api/event';\n * interface LoadedPayload {\n *   loggedIn: boolean,\n *   token: string\n * }\n * const unlisten = await once<LoadedPayload>('loaded', (event) => {\n *   console.log(`App is loaded, loggedIn: ${event.payload.loggedIn}, token: ${event.payload.token}`);\n * });\n *\n * // you need to call unlisten if your handler goes out of scope e.g. the component is unmounted\n * unlisten();\n * ```\n *\n * @param event Event name. Must include only alphanumeric characters, `-`, `/`, `:` and `_`.\n * @param handler Event handler callback.\n * @param options Event listening options.\n * @returns A promise resolving to a function to unlisten to the event.\n * Note that removing the listener is required if your listener goes out of scope e.g. the component is unmounted.\n *\n * @since 1.0.0\n */\nasync function once(event, handler, options) {\n    return listen(event, (eventData) => {\n        void _unlisten(event, eventData.id);\n        handler(eventData);\n    }, options);\n}\n/**\n * Emits an event to all {@link EventTarget|targets}.\n *\n * @example\n * ```typescript\n * import { emit } from '@tauri-apps/api/event';\n * await emit('frontend-loaded', { loggedIn: true, token: 'authToken' });\n * ```\n *\n * @param event Event name. Must include only alphanumeric characters, `-`, `/`, `:` and `_`.\n * @param payload Event payload.\n *\n * @since 1.0.0\n */\nasync function emit(event, payload) {\n    await invoke('plugin:event|emit', {\n        event,\n        payload\n    });\n}\n/**\n * Emits an event to all {@link EventTarget|targets} matching the given target.\n *\n * @example\n * ```typescript\n * import { emitTo } from '@tauri-apps/api/event';\n * await emitTo('main', 'frontend-loaded', { loggedIn: true, token: 'authToken' });\n * ```\n *\n * @param target Label of the target Window/Webview/WebviewWindow or raw {@link EventTarget} object.\n * @param event Event name. Must include only alphanumeric characters, `-`, `/`, `:` and `_`.\n * @param payload Event payload.\n *\n * @since 2.0.0\n */\nasync function emitTo(target, event, payload) {\n    const eventTarget = typeof target === 'string' ? { kind: 'AnyLabel', label: target } : target;\n    await invoke('plugin:event|emit_to', {\n        target: eventTarget,\n        event,\n        payload\n    });\n}\n\nexport { TauriEvent, emit, emitTo, listen, once };\n"],"names":[],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6]}